#pragma once

#include <string>
#include <vector>

#include "../../operators/get_table.hpp"
#include "../../operators/validate.hpp"
#include "../../utils/assert.hpp"

#include <nlohmann/json.hpp>

namespace opossum {
class JsonSerializer {
  using json = nlohmann::json;
  /***
  * convert a vector<T> into a json object
  * {
  *  "0": 1
  *  "1": {
  *      // some nested value
  *    }
  * }
  */
  template <typename T>
  static json vec_to_json(const std::vector<T>& vec);

  // asserts that the json value hold the a key with a value T
  template <typename T>
  static void key_of_type_exists(const json& value, const std::string& key);

  // retrieve data of type T from Json at key
  template <typename T>
  static T get_entry_from_json(const json& value, const std::string& key);

  using string_t =
      std::__cxx11::basic_string<char, std::char_traits<char>, boost::container::pmr::polymorphic_allocator<char>>;

  // used to align error messages after \n char
  static inline const std::string newline_spacer = "\n           ";

 public:
  // unserialize function
  template <typename T>
  static T from_json(const json& data);

  template <typename T>
  static auto from_json_str(const std::string& json_str);

  template <typename T>
  static json to_json(const T& object);

  template <typename T>
  static std::string to_json_str(const T& object);
};

template <typename T>
std::string JsonSerializer::to_json_str(const T& object) {
  return "";
}

template <typename T>
auto JsonSerializer::from_json_str(const std::string& json_str) {
  return nullptr;
}
}  // namespace opossum
/**
 {
        "_left_input":  {
                "_name":        "lineitem",
                "_pruned_chunk_ids":    {
                },
                "_pruned_column_ids":   {
                },
                "_type":        "GetTable"
        },
        "_type":        "Validate"
} */
/*
namespace nlohmann {
template <>
struct adl_serializer<opossum::ChunkID> {
  static void to_json(json& j, const opossum::ChunkID& chunk_id) { j = static_cast<int>(chunk_id); }

  static void from_json(const json& j, opossum::ChunkID& chunk_id) { chunk_id = j.get<int>(); }
};

template <>
struct adl_serializer<opossum::ColumnID> {
  static void to_json(json& j, const opossum::ColumnID& chunk_id) { j = static_cast<int>(chunk_id); }

  static void from_json(const json& j, opossum::ColumnID& chunk_id) { chunk_id = j.get<int>(); }
};

template <>
struct adl_serializer<opossum::OperatorType> {
  static void to_json(json& j, const opossum::OperatorType& op_t) { j = magic_enum::enum_name(op_t).data(); }

  static void from_json(const json& j, opossum::OperatorType& op_t) {
    op_t = magic_enum::enum_cast<opossum::OperatorType>(j.get<std::string>()).value();
  }
};

template <>
struct adl_serializer<opossum::GetTable> {
  static opossum::GetTable from_json(const json& j) {
    return {j.at("_name").get<std::string>(), j.at("_pruned_chunk_ids").get<std::vector<opossum::ChunkID>>(),
            j.at("_pruned_column_ids").get<std::vector<opossum::ColumnID>>()};
  }

  static void to_json(json& j, opossum::GetTable get_table) {
    j["_name"] = get_table._name;
    j["_pruned_chunk_ids"] = get_table._pruned_chunk_ids;
    j["_pruned_column_ids"] = get_table._pruned_column_ids;
  }
};

template <>
struct adl_serializer<std::shared_ptr<const opossum::GetTable>> {
  static std::shared_ptr<const opossum::GetTable> from_json(const json& j) {
    return std::make_shared<opossum::GetTable>(j.at("_name").get<std::string>(),
                                               j.at("_pruned_chunk_ids").get<std::vector<opossum::ChunkID>>(),
                                               j.at("_pruned_column_ids").get<std::vector<opossum::ColumnID>>());
  }

  static void to_json(json& j, std::shared_ptr<const opossum::GetTable> get_table) {
    j["_name"] = get_table->_name;
    j["_pruned_chunk_ids"] = get_table->_pruned_chunk_ids;
    j["_pruned_column_ids"] = get_table->_pruned_column_ids;
  }
};

template <>
struct adl_serializer<std::shared_ptr<opossum::GetTable>> {
  static std::shared_ptr<opossum::GetTable> from_json(const json& j) {
    return std::make_shared<opossum::GetTable>(j.at("_name").get<std::string>(),
                                               j.at("_pruned_chunk_ids").get<std::vector<opossum::ChunkID>>(),
                                               j.at("_pruned_column_ids").get<std::vector<opossum::ColumnID>>());
  }

  static void to_json(json& j, std::shared_ptr<opossum::GetTable> get_table) {
    j["_name"] = get_table->_name;
    j["_pruned_chunk_ids"] = get_table->_pruned_chunk_ids;
    j["_pruned_column_ids"] = get_table->_pruned_column_ids;
  }
};

template <>
struct adl_serializer<std::shared_ptr<const opossum::AbstractOperator>> {
  static std::shared_ptr<const opossum::AbstractOperator> from_json(const json& j) {
    const opossum::OperatorType op_t = magic_enum::enum_cast<opossum::OperatorType>(j["_type"]).value();
    switch (op_t) {
      case opossum::OperatorType::GetTable:
        std::cout << "GetTable" << std::endl;
        return adl_serializer<std::shared_ptr<const opossum::GetTable>>::from_json(j);

      default:
        Fail(magic_enum::enum_name(op_t).data());
    }
    return nullptr;
  }

  static void to_json(json& j, std::shared_ptr<const opossum::AbstractOperator> abstract_op) {
    switch (abstract_op->_type) {
      case opossum::OperatorType::GetTable:
        return adl_serializer<std::shared_ptr<const opossum::GetTable>>::to_json(
            j, std::dynamic_pointer_cast<const opossum::GetTable>(abstract_op));

      default:
        Fail(magic_enum::enum_name(abstract_op->_type).data());
    }
  }
};

template <>
struct adl_serializer<std::shared_ptr<opossum::AbstractOperator>> {
  static std::shared_ptr<opossum::AbstractOperator> from_json(const json& j) {
    const opossum::OperatorType op_t = magic_enum::enum_cast<opossum::OperatorType>(j["_type"]).value();
    switch (op_t) {
      case opossum::OperatorType::GetTable:
        std::cout << "GetTable" << std::endl;
        return adl_serializer<std::shared_ptr<opossum::GetTable>>::from_json(j);

      default:
        Fail(magic_enum::enum_name(op_t).data());
    }
    return nullptr;
  }

  static void to_json(json& j, std::shared_ptr<opossum::AbstractOperator> abstract_op) {
    switch (abstract_op->_type) {
      case opossum::OperatorType::GetTable:
        return adl_serializer<std::shared_ptr<opossum::GetTable>>::to_json(
            j, std::dynamic_pointer_cast<opossum::GetTable>(abstract_op));

      default:
        Fail(magic_enum::enum_name(abstract_op->_type).data());
    }
  }
};

template <>
struct adl_serializer<opossum::Validate> {
  static opossum::Validate from_json(const json& j) {
    const std::shared_ptr<opossum::AbstractOperator> abstract_op_shared_ptr =
        j.at("_left_input").get<std::shared_ptr<opossum::AbstractOperator>>();
    // auto validate_op_raw_ptr = dynamic_cast<opossum::Validate*>(abstract_op_shared_ptr.get());
    // return *validate_op_raw_ptr;
    return opossum::Validate{abstract_op_shared_ptr};
  }

  static void to_json(json& j, opossum::Validate validate) {
    std::shared_ptr<const opossum::Validate> left_in =
        std::shared_ptr<const opossum::Validate>(dynamic_cast<const opossum::Validate*>(validate._left_input.get()));
    json left_in_json;
    adl_serializer<std::shared_ptr<const opossum::AbstractOperator>>::to_json(
        left_in_json, std::dynamic_pointer_cast<const opossum::AbstractOperator>(left_in));
    j["_left_input"] = left_in_json;
    j["_type"] = validate._type;
  }
};

}  // namespace nlohmann
*/